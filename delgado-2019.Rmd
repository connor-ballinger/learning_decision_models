---
title: "Ovarian Cancer in Spain: Delgado 2019"
date: "`r conr::format_date()`"
author: "Connor Ballinger"
knit: conr::write_and_date
output: conr::format_html
---

```{r, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, comment = "")

library(tidyverse)
library(readxl)
library(janitor)
library(knitr)
library(lpSolve)

theme_set(theme_bw() + theme(legend.position = "bottom"))

```

# To do

-   **23/10 Try incorporating subsequent lines of treatment by tracking length of time in progressed state. Will have to use some kind of blanket rule - every x months, all patients in progressed state receive next treatment.**

-   **16/10 Don't think I can go any further - see questions below.**

-   Add yearly cohort with pop growth. 

-   Fix notes on Heintz survival extrapolation.

# Questions

-   How to add calculations for 2nd to 7th lines? No tunnel states, so no way of knowing which line is applicable. Same issue exists within lines as patients could change states between cycles.

      -   See Cheng 2021: I think they assume everyone in Progressed state is receiving treatment and assign portions to each treatment line. The source for these portions is Friedlander 2018 (Study-19), which has a supplementary table that states what portion of initial population eventually recieved each line of treatment. But, I think this would underestimate how many receive each treatment as censoring is obviously present. Overall, I think there needs to be something better.
      
      -   Point remains, Delgado doesn't seem to have done this.
      
-   Survival: I thought they used median survival time from Heintz 2006, but only Stages III and IV observe median survival, so I'm not sure how they parameterise Stages I and II. Also, Heintz only presents for sub-stages, not the 4 usual stages, though perhaps Delgado aggregated the groups.

      -   Delgado did it in reverse. Did not have median PFS/OS for each stage, but does have portions at five years.

# Overview

-   Epithelial OC (90% of OC is used).

-   3-state Markov (stable, progressed, death), stratified by the 4 stages. 

-   10-year horizon, societal perspective.

-   “The cycle length used was 3 weeks (21 days), which is the length of a chemotherapy cycle. Patients entered the model after they were diagnosed with EOC in the stable state... Those who progress remain in a post-progression state until they die.” 

-   Used Heintz 2006 for survival. Heintz only provided 5-year survival data – Delgado extrapolated based on exponential distribution i.e. time-constant transition probabilities.

-   Recall there may be no treatment effects applied - may just use Olaparib survival curves directly in an appropriate sub-population.

-   Note age-specific probabilities of death (incorporating OC mortality rate and background mortality rate).

    -   Always calculate probabilities and add rather than add rates and calculate probability.

# Assumptions

-   Neoadjuvant CT and all surgical treatment is administered in the first cycle, essentially as start-up costs.

# Aside

-   Appears you can't use arithmetic and pipe the result. Perform arithmetic and assign to object, then perform other functions in pipe chain.

    -   e.g. 1.5 + 1 |> round() = 2.5 but 1 + 1.5 |> round() = 3, since 1.5 gets rounded to 2.
    -   See [here](https://stackoverflow.com/questions/72352994/different-outputs-with-pipe-after-arithmetic-operator-vs-calling-it-directly):  the pipe precedes arithmetic functions in order of operations.
<br><br>

-   **See Hawkins 2005**: semi-Markov relies on a 3-D transition matrix (from state, to state, t) where t is time spent in current state. I think this is necessary, don't believe my current transition array captures this, right?? I know what portion transitions in and out each cycle... Imagine after 10 cycles - people have been in there for 0-9 cycles... I think I need more structure to track this...

# DARTH Framework (Alarid 2023)

-   Alarid-Escudero, F., Krijkamp, E., Enns, E. A., Yang, A., Hunink, M. G. M., Pechlivanoglou, P., & Jalal, H. (2023). A Tutorial on Time-Dependent Cohort State-Transition Models in R Using a Cost-Effectiveness Analysis Example. Medical Decision Making, 43(1), 21-41. doi:10.1177/0272989x221121747

-   Base R used in the interests of transparency and reducing the chance of running code without understanding it.

-   Objects are named with a prefix to indicate their type:

      -   n: number
      -   v: vector
      -   m: matrix
      -   a: array
      -   df: dataframe
<br><br>

-   Arrays are preferred to dataframes due to easier indexing and multiplication.

# Replication of Delgado

## Structure

```{r}
n_cycle_length <- 3 / 52 # 3 weeks
n_cycles <- round(10 / n_cycle_length) # 10 years

v_names_states <- c("Stable", "Progressed", "Dead")
v_names_stages <- c("I", "II", "III", "IV")
```

## Patients

```{r}
df_ages <- data.frame(cycle = 0:n_cycles, 
                      I = 57.4, 
                      II = 62.4, 
                      III = 64.9, 
                      IV = 68.1)
df_ages <- df_ages |>
  mutate(across(I:IV, ~ round(cycle * n_cycle_length + .x)))

df_ages_long <- df_ages |>
  pivot_longer(cols = -cycle, names_to = "stage", 
               values_to = "age", cols_vary = "slowest")
# df_ages_long
df_ages
```

## Transitions

-   Delgado assumed exponential distribution - time-constant probabilities (though background mortality varies by age).

-   Annual rates converted to 3-weekly rates by multiplying by 3/52.

### Background Mortality Rate

-   Australian (ABS) data used, not Spanish.

```{r}
df_life_table <- readxl::read_xlsx("abs_life_tables_2019-2021.xlsx", 
                                sheet = "Table_1.9",
                                skip = 6)
df_life_table <- df_life_table |> 
  select(Age, rate...7) |> 
  rename(age = Age, rate_annual_mort = rate...7)

# convert annual rate to 3-weekly rate

df_life_table <- df_life_table |> 
  mutate(age = as.integer(age),
         rate_bgr_mort = rate_annual_mort * n_cycle_length) |> 
  filter(between(age, 
                 min(df_ages_long$age), 
                 max(df_ages_long$age))) |> 
  select(age, rate_bgr_mort)

# ignore NA warning, that is due to ABS adding text below data

df_bgr_mort <- df_ages_long |> 
  left_join(df_life_table, by = "age")
df_bgr_mort
```

### Transition Rates - Heintz 2006

-   Median 5-year PFS and OS were published by stage. Delgado extrapolated assuming an exponential distribution.

-   **Change this - think they used portions published in Heintz, as opposed to t at median survival.**

$$S(t_{med}) = \frac{1}{2}$$
$$e^{-\lambda t_{med}} = \frac{1}{2}$$
$$t_{med} = \frac{\ln(2)}{\lambda}$$

$$\lambda = \frac{\ln(2)}{t_{med}}$$

```{r}
v_median_pfs <- c(18.33, 6.25, 2.00, 1.60)
v_median_os <- c(19.50, 7.50, 3.20, 1.90)

v_lambda_pfs <- - log(0.5) / v_median_pfs
v_3r_pfs <- v_lambda_pfs * n_cycle_length # 3-weekly rate

v_lambda_os <- - log(0.5) / (v_median_os - v_median_pfs)
v_3r_os <- v_lambda_os * n_cycle_length # 3-weekly rate

df_rates <- tibble(stage = v_names_stages,
                   rate_pfs = v_3r_pfs,
                   rate_os = v_3r_os)
df_rates
```

### All Rates to Probabilities

-   Convert rates to probabilities: $P = 1 - e^{-\lambda}$

```{r}
df_prob <- df_bgr_mort |> 
  left_join(df_rates, by = "stage") |> 
  mutate(across(.cols = starts_with("rate"),
                .fns = ~ 1 - exp(-.x),
                .names = "prob_{.col}")) |> 
  rename_with(.fn = ~ sub("_rate", "", .x), .cols = everything()) |> 
  mutate(prob_s_p = prob_pfs,
         prob_s_d = prob_bgr_mort,
         prob_p_d = prob_os + prob_bgr_mort) |> 
  select(cycle, stage, prob_s_p, prob_s_d, prob_p_d)
df_prob
```

-   Convert to array.

```{r}
# Split df_prob by Stage

df_prob_stages <- split(df_prob, df_prob$stage)
names(df_prob_stages) <- v_names_stages

# Initialise probability array

a_prob <- array(data = as.double(NA), 
                dim = c(3, 3, 4, (n_cycles+1)), 
                dimnames = list("from" = v_names_states, 
                                "to" = v_names_states,
                                "stage" = v_names_stages,
                                "cycle" = 0:n_cycles))
# Prevent some transitions

a_prob["Dead", "Stable", , ] <- 
  a_prob["Dead", "Progressed", , ] <- 
  a_prob["Progressed", "Stable", , ] <- 0

# Dead stay dead

a_prob["Dead", "Dead", , ] <- 1

# Use purrr::walk such that assignments made for each Stage

# S to P
v_names_stages |> 
  walk(\(x) a_prob["Stable", "Progressed", x, ] <<- 
         df_prob_stages[[x]]$prob_s_p)

# S to D
v_names_stages |> 
  walk(\(x) a_prob["Stable", "Dead", x, ] <<-  
         df_prob_stages[[x]]$prob_s_d)

# P to D
v_names_stages |> 
  walk(\(x) a_prob["Progressed", "Dead", x, ] <<- 
         df_prob_stages[[x]]$prob_p_d)

# S to S means neither S to P nor S to D occur
v_names_stages |> 
  walk(\(x) a_prob["Stable", "Stable", x, ] <<- 
         (1 - a_prob["Stable", "Progressed", x, ] - 
            a_prob["Stable", "Dead", x, ]))

# P to P means P to D does not occur
v_names_stages |> 
  walk(\(x) a_prob["Progressed", "Progressed", x, ] <<- 
         (1 - a_prob["Progressed", "Dead", x, ]))

a_prob[, ,c("I", "IV") , c(1, n_cycles + 1)] |> round(3)
```

Only interested in amount of time in Progressed state - tunnel states might be best. Also, having both time- and state-dependence causes redundancy - e.g. cycle 0 still has dimensions for every single possibility for state-dependence.

But tunnel states increase dimensions even more than the alternative.

```{r}
a_prob_semi <- array(data = as.double(NA), 
                     dim = c(3, 3, 4, (n_cycles+1), (n_cycles + 1)), 
                     dimnames = list("from" = v_names_states, 
                                     "to" = v_names_states,
                                     "stage" = v_names_stages,
                                     "sojourn" = 0:n_cycles,
                                     "cycle" = 0:n_cycles))
#a_prob_semi[, , "I", 1:2, 1:2]

# Prevent some transitions

a_prob_semi["Dead", "Stable", , , ] <- 
  a_prob_semi["Dead", "Progressed", , , ] <- 
  a_prob_semi["Progressed", "Stable", , , ] <- 0

# Dead stay dead

a_prob_semi["Dead", "Dead", , , ] <- 1

# Use purrr::walk such that assignments made for each Stage

# S to P
v_names_stages |> 
  walk(\(x) a_prob_semi["Stable", "Progressed", x, , ] <<- 
         df_prob_stages[[x]]$prob_s_p)

# S to D
v_names_stages |> 
  walk(\(x) a_prob_semi["Stable", "Dead", x, , ] <<-  
         df_prob_stages[[x]]$prob_s_d)

# P to D
v_names_stages |> 
  walk(\(x) a_prob_semi["Progressed", "Dead", x, , ] <<- 
         df_prob_stages[[x]]$prob_p_d)

# S to S means neither S to P nor S to D occur
v_names_stages |> 
  walk(\(x) a_prob_semi["Stable", "Stable", x, , ] <<- 
         (1 - a_prob_semi["Stable", "Progressed", x, , ] - 
            a_prob_semi["Stable", "Dead", x, , ]))

# P to P means P to D does not occur
v_names_stages |> 
  walk(\(x) a_prob_semi["Progressed", "Progressed", x, , ] <<- 
         (1 - a_prob_semi["Progressed", "Dead", x, , ]))


```


```{r}
a_trace_semi <- array(data = NA, 
                      dim = c(3, 4, (n_cycles+1), (n_cycles+1)), 
                      dimnames = list("state" = v_names_states,
                                      "stage" = v_names_stages,
                                      "sojourn" = 0:n_cycles,
                                      "cycle" = 0:n_cycles))

a_trace_semi[, , "0", "0"] <- v_init_states %o% v_init_stages


for (stage in v_names_stages) {
  for (t in 2:(n_cycles + 1)) { # indexing by integer, not cycle name. cycle_name = integer - 1.
    for (sojourn in 1:n_cycles) {
      
      a_trace_semi[, stage, sojourn, t] <- 
        a_trace_semi[, stage, sojourn, t-1] %*% 
        a_prob_semi[, , stage, sojourn, t]
    
    }
  }
}

a_trace_semi[, , 1:2, 1:2]
rm(stage, t)
```


```{r}
v_names_tunnels <- c("Stable", paste0("Progressed_", 0:n_cycles), "Dead")

a_tunnel_prob <- array(data = as.double(NA), 
                  dim = c(length(v_names_tunnels), length(v_names_tunnels), 4, (n_cycles + 1)), 
                  dimnames = list("from" = v_names_tunnels, 
                                  "to" = v_names_tunnels,
                                  "stage" = v_names_stages,
                                  "cycle" = 0:n_cycles))
# More than 20x the size of the alternative
```

## Checks

```{r}
sum(a_prob >= 0 & a_prob <= 1) - length(a_prob)

tracker <- 0

for (stage in v_names_stages) {
  for (t in 1:n_cycles+1) {
    tracker = tracker + rowSums(a_prob[, , stage, t]) - 1
  }
}
tracker # should be zero
rm(stage, t, tracker)
```

## Construct Trace

```{r}
v_init_stages <- c(1155, 195, 1116, 681) # Delgado figures
# v_init_stages <- c(0.37, 0.06, 0.35, 0.22) # rough portions
# v_init_stages <- rep.int(1, times = 4)
names(v_init_stages) <- v_names_stages
v_init_states <- c(1, 0, 0) # all patients start in stable state

a_trace <- array(data = NA, 
                 dim = c(3, 4, n_cycles+1), 
                 dimnames = list("state" = v_names_states,
                                 "stage" = v_names_stages,
                                 "cycle" = 0:n_cycles))

a_trace[, , "0"] <- v_init_states %o% v_init_stages


for (stage in v_names_stages) {
  for (t in 2:(n_cycles + 1)) { # indexing by integer, not cycle name. cycle_name = integer - 1.
    a_trace[, stage, t] <- a_trace[, stage, t-1] %*% a_prob[, , stage, t]
  }
}

a_trace[, , c(1, n_cycles + 1)] |> 
  round()

rm(stage, t)
```

## Gather Results

```{r}
df_trace <- as.data.frame(aperm(a_trace)) |>
  mutate(Cycle = 0:n_cycles) |> 
  pivot_longer(cols = -(Cycle), 
               names_to = c("Stage", "State"),
               names_sep = "\\.",
               values_to = "N") |> 
  mutate(Year = Cycle * n_cycle_length,
         State = factor(State, 
                        levels = c("Stable", "Progressed", "Dead"), 
                        ordered = TRUE))

ggplot(data = df_trace) +
  geom_line(aes(x = Year, y = N, colour = Stage)) +
  facet_wrap(vars(State)) #, scales = "free_y")

ggplot(data = df_trace) +
  geom_line(aes(x = Year, y = N, colour = State)) +
  facet_wrap(vars(Stage), nrow = 1)
```

```{r}
df_trace_normalised <- as.data.frame(aperm(a_trace)) |> 
  mutate(Cycle = 0:n_cycles) |> 
  pivot_longer(cols = -(Cycle), 
               names_to = c("Stage", "State"),
               names_sep = "\\.",
               values_to = "Portion") |> 
  mutate(Portion = Portion * 1 / v_init_stages,
         Year = Cycle * n_cycle_length,
         State = factor(State, 
                        levels = c("Stable", "Progressed", "Dead"), 
                        ordered = TRUE))
  

ggplot(data = df_trace_normalised) +
  geom_line(aes(x = Year, y = Portion, colour = Stage)) + 
  facet_wrap(vars(State))

```

# Costs

-   Storing parameters:

    -   Misc params df_params_general
        -   Service use
    -   Service unit costs (could be a named vector) df_service_costs
    -   Drug unit costs (too many cols for named vector) df_drug_costs
    -   Drug dosing (fairly straightforward, could be reduced) df_drug_doses
    -   Drugs palliative (dose, market share, pre/post terminal) df_drug_pall
    -   Drugs market share (7 lines, first is split into 2) df_drug_use

## Overarching Cost Figures

```{r}
n_cpi_med <- 0.0077
n_cpi <- 0.0197
n_discount_rate <- 0.03
n_econ_growth <- 0.01


# m <- matrix(rep.int(1, 20), nrow = 5) # for checking calcs
```

## Services

-   Not sure what use it is to have portion of patients hospitalised/seen ED in a period (we only need the mean rate, right?).

```{r}
df_params_general <- read_xlsx("delgado_parameters.xlsx", sheet = 7) |> 
  clean_names() |> 
  rename(param = x1) |> 
  filter(if_any(stage_i:stage_iv, ~ !is.na(.x)))
df_params_general <- df_params_general[-1, ] |> 
  mutate(across(stage_i:stage_iv, as.numeric))

df_params_general$param <- c("median_pfs", "median_os", "mean_age", 
                             "mean_weight", "mean_height", "hospitalisations_n",
                             "hospitalised_perc", "emergencies_n",
                             "emergencies_perc", "tmt_none", "tmt_surgery",
                             "tmt_neoadjuvant_chemotherapy_surgery",
                             "tmt_surgery_adjuvant_chemotherapy", 
                             "surgery_laparotomy", "surgery_omentectomy",
                             "surgery_abdominal_total_hysterectomy",
                             "surgery_bilateral_salpingo_oophorectomy", 
                             "surgery_lymphadenectomy")
df_params_general

m_params <- df_params_general |> 
  column_to_rownames(var = "param") |> 
  as.matrix()
m_params <- clean_names(m_params)

```

### Calculate Volume of Services

```{r, results='hold'}
# initial surgery

v_names_tmt_strategy <- grep("^tmt", rownames(m_params), value = TRUE)
v_names_surgery <- grep("^surgery", rownames(m_params), value = TRUE)

v_vol_any_surgery <- 
  colSums(m_params[grep("surgery", v_names_tmt_strategy, value = TRUE), ]) *
  v_init_stages

v_vol_any_surgery <- conr::round_sensibly(v_vol_any_surgery)


cat("Initial Surgery Volumes\n")
m_vol_surgery <- m_params[v_names_surgery, ] * 
  matrix(rep(v_vol_any_surgery, 5), ncol = 4, byrow = TRUE)
m_vol_surgery <- conr::round_sensibly(m_vol_surgery) # not working?
m_vol_surgery

# hospital episodes
cat("\n3-Weekly Rate of Presentations\n")
m_rate_episode <- m_params[c("hospitalisations_n",
                             "emergencies_n"), ] * n_cycle_length
conr::round_sensibly(m_rate_episode, 2)
```

### Service Unit Costs

```{r}
df_service_costs <- read_xlsx("delgado_parameters.xlsx", sheet = 1) |> 
  clean_names()
df_service_costs <- df_service_costs |> 
  select(-(references)) |> 
  rename(service = x1,
         cost = costs_2016) |> 
  drop_na(cost) |> 
  mutate(service = make_clean_names(service),
         cost = as.double(cost))
df_service_costs

v_cost_services <- deframe(df_service_costs)
```

-   Can't understand what they did with BRCA testing.

```{r}
n_brca_ref_rate <- 0.2
n_brca_ref_visits <- 2
n_brca_pos_rate <- 0.05
n_brca_family_refs <- 5

n_vol_brca_test <- sum(v_init_stages) * n_brca_ref_rate
n_vol_brca_pos <- n_vol_brca_test * n_brca_pos_rate
n_vol_brca_indirect <- n_vol_brca_pos * 5 # do the 5 relatives have BRCA test?

# difficult to interpret what they did
```

### Total Cost of Services

-   Initial surgery costs:

```{r}
# is this shit code or fine?
names(v_cost_services)[
  v_names_surgery |> 
  gsub("surgery", "", x = _) |> 
  map(\(x) agrep(x, names(v_cost_services))) |> 
  unlist()
] <- v_names_surgery


m_surg_cost <- m_vol_surgery *
  v_cost_services[v_names_surgery]


m_surg_cost |> colSums() |> scales::label_dollar()(x = _) |> enframe()
m_surg_cost |> rowSums() |> scales::label_dollar()(x = _) |> enframe()
```

-   3-weekly cost of episodes:

```{r}
m_episode_cost <- m_rate_episode * 
  v_cost_services[c("ovarian_cancer_hospitalization", 
                    "emergency_department_attendance")]
rownames(m_episode_cost) <- gsub("\\_n", "", rownames(m_episode_cost))
conr::round_sensibly(m_episode_cost)

```

## Drugs

### Drug Unit Costs

-   Bevacizumab is Avastin.

-   DOXORUBICINE PEGYLATED / DOXORUBICIN is Caelyx.

-   Trabectedin is Yondelis. 

```{r}
df_drug_costs <- read_xlsx("delgado_parameters.xlsx", sheet = 2, skip = 1) |> 
  clean_names()
df_drug_costs <- df_drug_costs |> 
  select(-(list_price_lp)) |> 
  rename(drug = x1, 
         cost = lp_rdl_vat) |> 
  drop_na(cost)

df_drug_costs <- df_drug_costs |> 
  separate_wider_delim(cols = drug, delim = " ", names = c("drug", "unit"), 
                       too_many = "merge") |> 
  mutate(unit = str_replace(unit, "([0-9]*)\\.?([0-9]*)( G )", paste0("\\1", "\\2", "000", "\\3")),
         quantity_ml = as.double(str_extract(unit, "([0-9]*\\.?[0-9]+) ML\\)", group = 1)),
         quantity_mg = as.double(str_extract(unit, "([0-9]*\\.?[0-9]+) MG ", group = 1)),
         mg_per_ml = as.double(str_extract(unit, "([0-9]*\\.?[0-9]*) MG\\/ML", group = 1)),
         mg_per_vial = if_else(!is.na(quantity_mg), quantity_mg, quantity_ml * mg_per_ml),
         drug = str_to_title(drug))

df_drug_costs <- df_drug_costs |> 
  mutate(drug = case_when(drug == "Avastin" ~ "Bevacizumab",
                          drug == "Caelyx" ~ "Doxorubicine",
                          drug == "Yondelis" ~ "Trabectedin",
                          .default = drug)) |> 
  arrange(drug, cost)


dox <- df_drug_costs[grep("Doxo", df_drug_costs$drug), ] # Doxorubicine
dox[2, ] <- dox[1, ]
dox$drug[[1]] <- "Doxorubicin monotherapy"
dox$drug[[2]] <- "Doxorubicin in combination"

df_drug_costs <- df_drug_costs |> 
  add_case(dox) |> 
  arrange(drug, cost)

df_drug_costs
```

### Drug Dosing

-   Measured in mg.

```{r}
df_drug_doses <- read_xlsx("delgado_parameters.xlsx", sheet = 3, skip = 2) |> 
  clean_names()
df_drug_doses <- df_drug_doses |> 
  rename(drug = x1,
         time_hours = x6) |> 
  mutate(drug = gsub("[[:punct:]]", "", drug)) |> 
  arrange(drug)
df_drug_doses

m_drug_doses <- df_drug_doses |> 
  column_to_rownames(var = "drug") |>
  as.matrix()

```

### Drug Market Share

```{r}
df_drug_use <- read_xlsx("delgado_parameters.xlsx",
                         sheet = 4, skip = 2, na = "-") |> 
  clean_names()

df_drug_use <- df_drug_use |> 
  rename(drug = x1,
         line1_stages_i_ii = stages_i_and_ii,
         line1_stages_iii_iv = stages_iii_and_iv,
         line2 = x4,
         line3 = x5,
         line4 = x6,
         line5 = x7,
         line6 = x8,
         line7 = x9) |> 
  mutate(across(.cols = -c(1), as.double)) |> 
  mutate(drug = gsub("[[:punct:]]", "", drug)) |> 
  arrange(drug)
df_drug_use

m_drug_use <- df_drug_use |>
  column_to_rownames(var = "drug") |> 
  as.matrix()

```

### CT Drug Calculations

-   CT dependent on stage only for first line. Second line only administered when in progressed state.

-   How do later lines work?

-   How does costing work? 

    -   Calculate optimal use of vials.
    -   Get cost of one administration.
    -   Markov cycle length is same as treatment cycle, presumably with the intention of allowing transitions between cycles, meaning there is no assumption that all patients complete all treatment lines which they start.
<br><br>

-   Optimise selection of vials w.r.t. cost, under a single constraint of minimum dose required. Calculate for each drug, each stage, and calculate cost.

```{r}
fn_calc_drugs <- function(drug_name, stage = "stage_i") {
  
  df_drug = filter(df_drug_costs, drug == drug_name)
  quantities = df_drug$mg_per_vial
  cost = df_drug$cost
  dose = m_drug_doses[drug_name, stage]
  
  opt = lp(direction = "min",
           objective.in = cost,
           const.mat = t(quantities),
           const.dir = c(">="),
           const.rhs = dose,
           all.int = TRUE)
  
  tibble(drug = df_drug$drug,
         info = df_drug$unit,
         mg = as.vector(opt$constraints)[-c(length(opt$constraints), 
                                               length(opt$constraints) - 1)],
         unit_cost = opt$objective,
         dose_needed = dose,
         stage = stage,
         vials_n = opt$solution,
         total_cost = opt$objval) |> 
    filter(vials_n != 0)
}


fn_calc_all_drugs <- function() {
  
  stage_names = tolower(paste0("stage_", v_names_stages))
  drug_names = unique(df_drug_use$drug)
  
  df = tibble(drug = NA,
              info = NA,
              mg = NA,
              unit_cost = NA,
              dose_needed = NA,
              stage = NA,
              vials_n = NA,
              total_cost = NA)
  
  for (drug in drug_names) {
      for (stage in stage_names) {
        drug_result = fn_calc_drugs(drug, stage)
        df = df |> add_row(drug_result)
      }
  }
  df[-1, ] |>  # drop the shitty first row
    mutate(cost_for_vials = unit_cost * vials_n, .before = total_cost)
}

df_drugs_derived <- fn_calc_all_drugs()
df_drugs_derived

m_costed_drugs <- df_drugs_derived |> 
  distinct(drug, stage, .keep_all = TRUE) |> 
  select(drug, stage, total_cost) |> 
  pivot_wider(names_from = stage, values_from = total_cost) |> 
  column_to_rownames("drug") |> 
  as.matrix()

m_costed_drugs |> conr::round_sensibly()
```

### CT Questions

-   Maybe model starts immediately after surgery, so neoadjuvant CT is guaranteed, as is first cycle of post-surgical CT. Subsequent two cycles are not guaranteed.

-   Per paper: 

    -   Neoadjuvant receive 3 cycles of paclitaxel with carboplatin prior to surgery and 3 cycles post-surgery.
    -   Adjuvant administered post-surgery in Stable state (I, II, and III).
    -   Post-progression chemo administered post-progression for Stages I and II.
    -   Advanced treatment for Stage III post-progression and both states for Stage IV. **But they haven't defined advanced chemotherapy...**
<br><br>

-   How do you track lines of treatment? As people transition to Progressed state, they should start cycle 1 of line 2. How do you know when they have had 6 cycles and completed line 2?

### Neoadjuvant Cost: per person, per cycle

-   3 cycles prior to surgery (Carboplatin and Paclitaxel specified), plus another 3 post-surgery (same treatment? For Stable state only?)

-   Restricted to Stages III and IV.

-   These figures are weighted by the portion of people who receive neoadjuvant CT and first-line Carboplatin and Paclitaxel. So, these costs are per person in each stage, not per person who receives this treatment.

```{r}
m_cost_neo_pp <- m_costed_drugs[c("Carboplatin", "Paclitaxel"), 3:4] %*% 
  diag(m_params[grep("neoadjuvant", rownames(m_params)), 3:4]) %*%
  diag(m_drug_use[c("Carboplatin", "Paclitaxel"), "line1_stages_iii_iv"])

colnames(m_cost_neo_pp) <- c("III", "IV")
m_cost_neo_pp
```

### Adjuvant: Cost per person, per cycle

-   Post-surgical treatment for Stages I, II, and III in Stable state only for first 6 cycles.

```{r}
m_line1_use <- df_drug_use |> 
  select(1:3) |> 
  rename(stage_i = line1_stages_i_ii,
         stage_iv = line1_stages_iii_iv) |> 
  mutate(stage_ii = stage_i,
         stage_iii = stage_iv,
         .before = stage_iv) |> 
  arrange(drug) |> 
  column_to_rownames("drug") |> 
  as.matrix()
# m_line1_use

m_line1_use <- ifelse(is.na(m_line1_use), 0, m_line1_use)

m_cost_adjuvant <- 
  m_line1_use[rownames(m_costed_drugs), ] * 
  m_costed_drugs %*% 
  diag(m_params[grep("_adjuvant", rownames(m_params)), ])

m_cost_adjuvant
```

## Initialise Cost Array

-   Maybe the cost array doesn't need everything, it can use the transition matrix and the trace for calculations... Separate arrays for each cost category rather than separate dimensions?

-   Bring the per person cost here, multiply trace for total cost at each cycle, for each stage. Multiply by portion of patients in treatment strategy and portion of patients who receive drug.

-   Often have to add costs, not reassign the existing matrix value...

```{r}
a_costs <- array(data = 0, 
                 dim = c(nrow(m_costed_drugs),
                         4,
                         n_cycles + 1), 
                 dimnames = list("drug_cost" = rownames(m_costed_drugs),
                                 "stage" = v_names_stages,
                                 "cycle" = 0:n_cycles))

# Is there a need to add the State dimension? Not really interested in how cost
# varies by State, just need to account for it. So probably omit.

# Neoadjuvant

## three cycles before surgery

a_costs[rownames(m_cost_neo_pp), colnames(m_cost_neo_pp), "0"] <- 
  a_costs[rownames(m_cost_neo_pp), colnames(m_cost_neo_pp), "0"] +
  m_cost_neo_pp %*% diag(a_trace["Stable", colnames(m_cost_neo_pp) , "0"]) * 3

## what about three cycles post-surgery? Assume they need to be in Stable.

1:3 |> 
  walk(\(x) a_costs[rownames(m_cost_neo_pp), colnames(m_cost_neo_pp), x] <<- 
         a_costs[rownames(m_cost_neo_pp), colnames(m_cost_neo_pp), x] +
         m_cost_neo_pp %*% diag(a_trace["Stable", colnames(m_cost_neo_pp) , x])
  )

# Adjuvant

# 6 cycles following surgery

1:6 |> 
  walk(\(x) a_costs[, , x] <<- 
         a_costs[, , x] +
         m_cost_adjuvant %*% diag(a_trace["Stable", , x])
  )

a_costs[, , "5"] |> 
  conr::round_sensibly() |> 
  format(big.mark = ",") |>
  as.data.frame() |> 
  rownames_to_column(var = "Drug") |> 
  as_tibble()

a_costs[, , 1:2]
```

### Post-Progression CT (Subsequent Lines)

-   How does this work? Should there be an estimate of how many people are on each line at any given moment? Also, not everyone would receive 7 lines of treatment - Delgado should account for this somehow.

-   Median OS is never more than 1.3 years greater than median PFS - not much time to get through another 6 lines of treatment, at least in the median case.

```{r}
df_drug_use |> 
  select(-c(contains("line1")))


a_costs[, , 2] <- a_costs[, , 2] +
  m_costed_drugs * 
  m_drug_use[, "line2"] %*% 
  t(a_trace["Progressed", , 2])
```


### Palliative drugs

```{r}
df_drug_pall <- read_xlsx("delgado_parameters.xlsx", sheet = 5, skip = 2) |> 
  clean_names()
df_drug_pall <- df_drug_pall |> 
  rename(drug = x1,
         use_pre_terminal = use_of_drugs_2,
         daily_dose_pre_terminal = daily_dose_mg_m_l_3,
         use_post_terminal = use_of_drugs_4,
         daily_dose_post_terminal = daily_dose_mg_m_l_5)
df_drug_pall
```

```{r}
anti_join(df_drug_costs, df_drug_doses, by = "drug")
```

