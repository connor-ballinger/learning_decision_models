---
title: "Ovarian Cancer in Spain: Delgado 2019"
date: "`r conr::format_date()`"
author: "Connor Ballinger"
knit: conr::write_and_date
output: conr::format_html
---

```{r, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, comment = "")

# library(here)
library(tidyverse)
library(readxl)
library(janitor)
library(knitr)
library(lpSolve)

theme_set(theme_bw() + theme(legend.position = "bottom"))

```

# Overview

-   Epithelial OC (90% of OC is used).

-   3-state Markov (stable, progressed, death), stratified by the 4 stages. 

-   10-year horizon, societal perspective.

-   “The cycle length used was 3 weeks (21 days), which is the length of a chemotherapy cycle. Patients entered the model after they were diagnosed with EOC in the stable state... Those who progress remain in a post-progression state until they die.” 

-   Used Heintz 2006 for survival. Heintz only provided 5-year survival data – Delgado extrapolated based on exponential distribution ie time-constant transition probabilities.

-   Recall there may be no treatment effects applied - may just use Olaparib survival curves directly in an appropriate sub-population.

-   Note age-specific probabilities of death (incorporating OC mortality rate and background mortality rate).

    -   Add 2 rates and then calculate probability, or calculate probabilities and add? Delgado uses the latter. Always the latter.

# To do

-   Add yearly cohort with pop growth too. 

-   Add costs.

-   Construct a critique, including any Aus contextual factors.

-   Add equations.

# DARTH Framework (Alarid 2023)

-   Alarid-Escudero, F., Krijkamp, E., Enns, E. A., Yang, A., Hunink, M. G. M., Pechlivanoglou, P., & Jalal, H. (2023). A Tutorial on Time-Dependent Cohort State-Transition Models in R Using a Cost-Effectiveness Analysis Example. Medical Decision Making, 43(1), 21-41. doi:10.1177/0272989x221121747

-   Base R used in the interests of transparency and reducing the chance of running code without understanding it.

-   Objects are named with a prefix to indicate their type:

      -   n: number
      -   v: vector
      -   m: matrix
      -   a: array (generalisation of matrix)
      -   df: dataframe
<br><br>
-   Arrays are preferred to dataframes due to easier indexing and multiplication.

# Replication of Delgado

## Structure

```{r}
n_cycle_length <- 3 / 52 # 3 weeks
n_cycles <- round(10 / n_cycle_length) # 10 years

v_names_states <- c("Stable", "Progressed", "Dead")
v_names_stages <- c("I", "II", "III", "IV")
```

## Patients

```{r}
df_ages <- data.frame(cycle = 0:n_cycles, 
                      I = 57.4, 
                      II = 62.4, 
                      III = 64.9, 
                      IV = 68.1)
df_ages <- df_ages |>
  mutate(across(I:IV, ~ round(cycle * n_cycle_length + .x)))

df_ages_long <- df_ages |>
  pivot_longer(cols = -cycle, names_to = "stage", 
               values_to = "age", cols_vary = "slowest")
df_ages_long
```

## Transitions

-   Formulas in Delgado suggest probabilities vary over time, but they have assumed exponential so I don't see how.

-   Annual rates converted to 3-weekly rates by multiplying by 3/52.

### Background Mortality Rate

```{r}
df_life_table <- readxl::read_xlsx("abs_life_tables_2019-2021.xlsx", 
                                sheet = "Table_1.9",
                                skip = 6)
df_life_table <- df_life_table |> 
  select(Age, rate...7) |> 
  rename(age = Age, rate_annual_mort = rate...7)

# convert annual rate to 3-weekly rate

df_life_table <- df_life_table |> 
  mutate(age = as.integer(age),
         rate_bgr_mort = rate_annual_mort * n_cycle_length) |> 
  filter(between(age, 
                 min(df_ages_long$age), 
                 max(df_ages_long$age))) |> 
  select(age, rate_bgr_mort)

# ignore NA warning, that is due to ABS adding text below data

df_bgr_mort <- df_ages_long |> 
  left_join(df_life_table, by = "age")
df_bgr_mort
```

### Transition Rates - Heintz 2006

-   Median 5-year PFS and OS were published by stage. Delgado extrapolated assuming an exponential distribution.

$$S(t_{med}) = \frac{1}{2}$$
$$e^{-\lambda t_{med}} = \frac{1}{2}$$
$$t_{med} = \frac{\ln(2)}{\lambda}$$

    -   Alternately:

$$\lambda = \frac{\ln(2)}{t_{med}}$$

```{r}
v_median_pfs <- c(18.33, 6.25, 2.00, 1.60)
v_median_os <- c(19.50, 7.50, 3.20, 1.90)

v_lambda_pfs <- - log(0.5) / v_median_pfs
v_3r_pfs <- v_lambda_pfs * n_cycle_length # 3-weekly rate

v_lambda_os <- - log(0.5) / (v_median_os - v_median_pfs)
v_3r_os <- v_lambda_os * n_cycle_length # 3-weekly rate

df_rates <- tibble(stage = v_names_stages,
                   rate_pfs = v_3r_pfs,
                   rate_os = v_3r_os)
df_rates
```

### All Rates to Probabilities

-   Convert rates to probabilities: $P = 1 - e^{-\lambda}$

```{r}
df_prob <- df_bgr_mort |> 
  left_join(df_rates, by = "stage") |> 
  mutate(across(.cols = starts_with("rate"),
                .fns = ~ 1 - exp(-.x),
                .names = "prob_{.col}")) |> 
  rename_with(.fn = ~ sub("_rate", "", .x), .cols = everything()) |> 
  mutate(prob_s_p = prob_pfs,
         prob_s_d = prob_bgr_mort,
         prob_p_d = prob_os + prob_bgr_mort) |> 
  select(cycle, stage, prob_s_p, prob_s_d, prob_p_d)
df_prob
```

-   Convert to array.

```{r}
# Split df_prob by Stage

df_prob_stages <- split(df_prob, df_prob$stage)
names(df_prob_stages) <- v_names_stages

# Initialise probability array

a_prob <- array(data = as.double(NA), 
                dim = c(3, 3, 4, (n_cycles+1)), 
                dimnames = list("from" = v_names_states, 
                                "to" = v_names_states,
                                "stage" = v_names_stages,
                                "cycle" = 0:n_cycles))
# Prevent some transitions

a_prob["Dead", "Stable", , ] <- 
  a_prob["Dead", "Progressed", , ] <- 
  a_prob["Progressed", "Stable", , ] <- 0

# Dead stay dead

a_prob["Dead", "Dead", , ] <- 1

# Use purrr::walk fn such that assignments made for each Stage

# S to P
v_names_stages |> 
  walk(\(x) a_prob["Stable", "Progressed", x, ] <<- 
         df_prob_stages[[x]]$prob_s_p)

# S to D
v_names_stages |> 
  walk(\(x) a_prob["Stable", "Dead", x, ] <<-  
         df_prob_stages[[x]]$prob_s_d)

# P to D
v_names_stages |> 
  walk(\(x) a_prob["Progressed", "Dead", x, ] <<- 
         df_prob_stages[[x]]$prob_p_d)

# S to S means neither S to P nor S to D occur
v_names_stages |> 
  walk(\(x) a_prob["Stable", "Stable", x, ] <<- 
         (1 - a_prob["Stable", "Progressed", x, ] - 
            a_prob["Stable", "Dead", x, ]))

# P to P means P to D does not occur
v_names_stages |> 
  walk(\(x) a_prob["Progressed", "Progressed", x, ] <<- 
         (1 - a_prob["Progressed", "Dead", x, ]))

a_prob[, ,c("I", "IV") , c(1, n_cycles + 1)] |> round(3)
```

## Checks

```{r}
sum(a_prob >= 0 & a_prob <= 1) - length(a_prob)

tracker <- 0

for (stage in v_names_stages) {
  for (t in 1:n_cycles+1) {
    tracker = tracker + rowSums(a_prob[, , stage, t]) - 1
  }
}
tracker # should be zero
```

## Construct Trace

```{r}
v_init_stages <- c(1155, 195, 1116, 681) # Delgado figures
# v_init_stages <- c(0.37, 0.06, 0.35, 0.22) # rough portions
# v_init_stages <- rep.int(1, times = 4)
v_init_states <- c(1, 0, 0) # all patients start in stable state

a_trace <- array(data = NA, 
                 dim = c(3, 4, n_cycles+1), 
                 dimnames = list("state" = v_names_states,
                                 "stage" = v_names_stages,
                                 "cycle" = 0:n_cycles))

a_trace[, , "0"] <- v_init_states %o% v_init_stages


for (stage in v_names_stages) {
  for (t in 2:(n_cycles + 1)) { # indexing by integer, not cycle name. cycle_name = integer - 1.
    a_trace[, stage, t] <- a_trace[, stage, t-1] %*% a_prob[, , stage, t]
  }
}

a_trace[, , c(1, n_cycles + 1)] |> 
  round()
```

## Gather Results

```{r}
df_trace <- as.data.frame(aperm(a_trace)) |>
  mutate(Cycle = 0:n_cycles) |> 
  pivot_longer(cols = -(Cycle), 
               names_to = c("Stage", "State"),
               names_sep = "\\.",
               values_to = "N") |> 
  mutate(Year = Cycle * n_cycle_length,
         State = factor(State, 
                        levels = c("Stable", "Progressed", "Dead"), 
                        ordered = TRUE))

ggplot(data = df_trace) +
  geom_line(aes(x = Year, y = N, colour = Stage)) +
  facet_wrap(vars(State)) #, scales = "free_y")

ggplot(data = df_trace) +
  geom_line(aes(x = Year, y = N, colour = State)) +
  facet_wrap(vars(Stage), nrow = 1)
```

# Costs

## Overarching Cost Figures

```{r}
n_cpi_med <- 0.0077
n_cpi <- 0.0197
n_discount_rate <- 0.03
n_econ_growth <- 0.01


m <- matrix(rep.int(1, 20), nrow = 5) # for checking calcs
```

## Services

-   Not sure what use it is to have portion of patients hospitalised/seen ED in a period (we only need the mean rate, right?).

```{r}
df_key_params <- read_xlsx("delgado_parameters.xlsx", sheet = 7) |> 
  clean_names() |> 
  rename(param = x1) |> 
  filter(if_any(stage_i:stage_iv, ~ !is.na(.x)))
df_key_params <- df_key_params[-1, ] |> 
  mutate(across(stage_i:stage_iv, as.numeric))
df_key_params

m_params <- df_key_params |> 
  column_to_rownames(var = "param") |> 
  as.matrix()
m_params <- clean_names(m_params)

```

### Calculate Volume of Services

-   Should I name all these vectors using stage names, where relevant? eg v_init_stages.

```{r, results='hold'}
# initial surgery

names(v_init_stages) <- v_names_stages

v_names_tmt_strategy <- dimnames(m_params)[[1]][10:13]
v_names_surgery <- dimnames(m_params)[[1]][14:18]

v_vol_any_surgery <- colSums(m_params[grep("surgery", dimnames(m_params)[[1]]), ]) * v_init_stages

cat("Initial Surgery Volumes\n")
m_vol_surgery <- m_params[v_names_surgery, ] * 
    matrix(rep(v_vol_any_surgery, 5), ncol = 4, byrow = TRUE)
conr::round_sensibly(m_vol_surgery)

# hospital episodes

cat("\n 3-Weekly Rate of Presentations\n")
m_rate_episode <- m_params[c("number_of_hospitalizations", "number_of_emergencies"), ] * n_cycle_length
conr::round_sensibly(m_rate_episode, 2)
```

### Service Unit Costs

```{r}
df_service_costs <- read_xlsx("delgado_parameters.xlsx", sheet = 1) |> 
  clean_names()
df_service_costs <- df_service_costs |> 
  select(-(references)) |> 
  rename(service = x1,
         cost = costs_2016) |> 
  drop_na(cost) |> 
  mutate(service = make_clean_names(service),
         cost = as.double(cost))
df_service_costs

v_cost_services <- deframe(df_service_costs)
```

-   BRCA testing seems to be quite removed from other calculations.

```{r}
n_brca_ref_rate <- 0.2
n_brca_ref_visits <- 2
n_brca_pos_rate <- 0.05
n_brca_family_refs <- 5

n_vol_brca_test <- sum(v_init_stages) * n_brca_ref_rate
n_vol_brca_pos <- n_vol_brca_test * n_brca_pos_rate
n_vol_brca_indirect <- n_vol_brca_pos * 5 # do the 5 relatives have BRCA test?

# difficult to interpret what they did
```

### Total Cost of Services

```{r, results='hold'}
cat("Initial Surgery Costs \n")
m_surg_cost <- m_vol_surgery *
  v_cost_services[c("laparotomy", 
                    "abdominal_total_hysterectomy", 
                    "lymphadenectomy",
                    "omentectomy",
                    "bilateral_salpingoophorectomy")]
conr::round_sensibly(m_surg_cost)

cat("\n 3-Weekly Presentations Cost \n")
m_episode_cost <- m_rate_episode * 
  v_cost_services[c("ovarian_cancer_hospitalization", 
                    "emergency_department_attendance")]
dimnames(m_episode_cost)[[1]] <- gsub("[a-z]*\\_", "", dimnames(m_episode_cost)[[1]])
conr::round_sensibly(m_episode_cost)
```

## Drugs

### Drug Unit Costs

```{r}
df_drug_costs <- read_xlsx("delgado_parameters.xlsx", sheet = 2, skip = 1) |> 
  clean_names()
df_drug_costs <- df_drug_costs |> 
  select(-(list_price_lp)) |> 
  rename(drug = x1, 
         cost = lp_rdl_vat) |> 
  drop_na(cost)

df_drug_costs <- df_drug_costs |> 
  separate_wider_delim(cols = drug, delim = " ", names = c("drug", "unit"), 
                       too_many = "merge") |> 
  mutate(quantity_ml = as.double(str_extract(unit, "([0-9]*\\.?[0-9]+) ML\\)", group = 1)),
         drug = str_to_title(drug)) |> 
  arrange(drug, cost)

df_drug_costs
```

### Drug Dosing

```{r}
df_drug_doses <- read_xlsx("delgado_parameters.xlsx", sheet = 3, skip = 2) |> 
  clean_names()
df_drug_doses <- df_drug_doses |> 
  rename(drug = x1,
         time_hours = x6) |> 
  mutate(drug = gsub("[[:punct:]]", "", drug))
df_drug_doses

m_drug_doses <- df_drug_doses |> 
  column_to_rownames(var = "drug") |>
  as.matrix()

```

### Drug Market Share

```{r}
df_drug_use <- read_xlsx("delgado_parameters.xlsx", sheet = 4, skip = 2, na = "-") |> 
  clean_names()
df_drug_use <- df_drug_use |> 
  rename(drug = x1,
         line1_stages_i_ii = stages_i_and_ii,
         line1_stages_iii_iv = stages_iii_and_iv,
         line2 = x4,
         line3 = x5,
         line4 = x6,
         line5 = x7,
         line6 = x8,
         line7 = x9) |> 
  mutate(across(.cols = -c(1), as.double)) |> 
  mutate(drug = gsub("[[:punct:]]", "", drug))
df_drug_use

m_drug_use <- df_drug_use |>
  column_to_rownames(var = "drug") |> 
  as.matrix()

```

### Drugs Missing Data

-   Missing dosing for some drugs, missing costs for others.

```{r}
df_key_drugs <- inner_join(df_drug_costs, df_drug_doses, by = "drug")
(df_drugs_missing_dose <- anti_join(df_drug_costs, df_key_drugs, by = "drug") |> 
    mutate(dose = NA))
(df_drugs_missing_cost <- anti_join(df_drug_doses, df_key_drugs, by = "drug") |> 
    mutate(unit_cost = NA))
```

### Drug Calculations

-   Initial, one-off treatment which most receive, and subsequent treatment according to the trace.

-   Dependent on stage only for first line. Second line only administered when in progressed state.

-   How do later lines work?

-   How does costing work? 

    -   Calculate optimal use of vials.
    -   Get cost of one administration.
    -   Markov cycle length is same as treatment cycle, presumably with the intention of allowing transitions between cycles, meaning there is no assumption that all patients complete all treatment lines which they start.

<br>

-   Optimise selection of vials w.r.t. cost, under a single constraint of minimum dose required. Calculate for each drug, each stage, and calculate cost.

```{r}
fn_calc_drugs <- function(drug_name, stage = "stage_i") {
  
  df_drug = filter(df_drug_costs, drug == drug_name)
  quantities = df_drug$quantity_ml
  cost = df_drug$cost
  dose = m_drug_doses[drug_name, stage]
  
  opt = lp(direction = "min",
           objective.in = cost,
           const.mat = t(quantities),
           const.dir = c(">="),
           const.rhs = dose,
           all.int = TRUE)
  
  tibble(drug = df_drug$drug,
         info = df_drug$unit,
         ml = as.vector(opt$constraints)[-c(length(opt$constraints), 
                                               length(opt$constraints) - 1)],
         unit_cost = opt$objective,
         dose_needed = dose,
         stage = stage,
         vials_n = opt$solution,
         total_cost = opt$objval) |> 
    filter(vials_n != 0)
}


fn_calc_all_drugs <- function() {
  
  stage_names = tolower(paste0("stage_", v_names_stages))
  drug_names = unique(df_key_drugs$drug)
  
  df = tibble(drug = NA,
              info = NA,
              ml = NA,
              unit_cost = NA,
              dose_needed = NA,
              stage = NA,
              vials_n = NA,
              total_cost = NA)
  
  for (drug in drug_names) {
      for (stage in stage_names) {
        drug_result = fn_calc_drugs(drug, stage)
        df = df |> add_row(drug_result)
      }
  }
  df[-1, ] |>  # drop the shitty first row
    mutate(cost_for_vials = unit_cost * vials_n, .before = total_cost)
}

my_drugs <- fn_calc_all_drugs()
my_drugs
m_costed_drugs <- my_drugs |> 
  distinct(drug, stage, .keep_all = TRUE) |> 
  select(drug, stage, total_cost) |> 
  pivot_wider(names_from = stage, values_from = total_cost) |> 
  column_to_rownames("drug") |> 
  as.matrix()

m_costed_drugs

```

```{r}
m_line1_use <- df_drug_use |> 
  select(1:3) |> 
  rename(stage_i = line1_stages_i_ii,
         stage_iv = line1_stages_iii_iv) |> 
  mutate(stage_ii = stage_i,
         stage_iii = stage_iv,
         .before = stage_iv) |> 
  arrange(drug) |> 
  column_to_rownames("drug") |> 
  as.matrix()
m_line1_use
```


### Palliative drugs

```{r}
df_drug_pall <- read_xlsx("delgado_parameters.xlsx", sheet = 5, skip = 2) |> 
  clean_names()
df_drug_pall <- df_drug_pall |> 
  rename(drug = x1,
         use_pre_terminal = use_of_drugs_2,
         daily_dose_pre_terminal = daily_dose_mg_m_l_3,
         use_post_terminal = use_of_drugs_4,
         daily_dose_post_terminal = daily_dose_mg_m_l_5)
df_drug_pall
```

